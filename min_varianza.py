# -*- coding: utf-8 -*-
"""min_varianza.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_qOPW-uTU6tp1pHvwEqlU-v7nt09-xbe
"""

import numpy as np      # Librería para cálculos numéricos
import pandas as pd     # Librería para manejar DataFrames
import scipy.optimize as op   # Librería para métodos de optimización
import sf_library as sfl      # Nuestra libreria

# Lista de tickers de sectores (ETF de SPDR)
tickers = [
    'XLK',  # Tecnología
    'XLF',  # Finanzas
    'XLV',  # Salud
    'XLP',  # Consumo básico
    'XLY',  # Consumo discrecional
    'XLE',  # Energía
    'XLI',  # Industrial
    'XLC',  # Comunicaciones
    'XLB',  # Materiales
    'XLU',  # Servicios públicos
    'XLRE', # Bienes raíces
]

# Lista donde guardaremos todas las series de retornos
all_returns = []

# Recorrer cada ticker
for ticker in tickers:
    t = sfl.daily_return(ticker, data_dir="MarketData")  # Carga los retornos diarios desde nuestra librería
    t = t[['date', 'return']].rename(columns={'return': ticker})  # Deja solo fecha y retorno, renombrando la columna
    all_returns.append(t)  # Guarda la serie en la lista


# Comenzamos la sincronización usando el primer DataFrame
df = all_returns[0]

# Unimos cada serie con las demás usando la fecha como llave
for t in all_returns[1:]:
    df = pd.merge(df, t, on='date', how='inner')  # Unión interna: solo fechas que existan en todos

# Limpiamos datos y ordenamos por fecha
df = df.dropna().sort_values('date').reset_index(drop=True)
# df = df[(df['date']<'2021-01-01')&(df['date']>'2019-01-01')]

# Filtro actual: solo fechas antes de 2019
df = df[df['date']<'2019-01-01']

df

mtx = df.drop(columns='date')          # Quita la columna 'date' para quedarse solo con los retornos numéricos
mtx_var_covar = mtx.cov().values * 252 # Calcula la matriz de varianza-covarianza y la anualiza multiplicando por 252
mtx_correl = mtx.corr().values         # Calcula la matriz de correlaciones entre todos los activos
mtx_var_covar                           # Muestra la matriz de varianza-covarianza

# ======================================
# Mínima varianza con descomposición de autovalores
# ======================================

eigenvalues, eigenvectors = np.linalg.eigh(mtx_var_covar)
# Calcula autovalores y autovectores de la matriz var-covar (simétrica → usar eigh)
min_var_vector = eigenvectors[:, 0]
# Toma el autovector asociado al autovalor más pequeño (columna 0)
# Este vector es la combinación lineal de mínima varianza

# # Prueba unitaria de la función de varianza
# variance_1 = np.matmul(
#     np.transpose(min_var_vector),           # Transpone el vector
#     np.matmul(mtx_var_covar, min_var_vector) # Multiplica para obtener la varianza resultante
# )

eigenvalues

eigenvectors

sum(min_var_vector**2)

mtx = df.drop(columns='date')                 # Elimina la columna 'date' para trabajar solo con retornos numéricos

mtx_var_covar = mtx.cov().values * 252        # Calcula la matriz varianza-covarianza y la anualiza (multiplica por 252 días)

mtx_correl = mtx.corr().values                # Calcula la matriz de correlaciones entre los activos



# ======================================
# Mínima varianza con descomposición de autovalores
# ======================================

eigenvalues, eigenvectors = np.linalg.eigh(mtx_var_covar)  # Calcula autovalores y autovectores de la matriz
min_var_vector = eigenvectors[:, 0]                        # Autovector asociado al autovalor más pequeño (mínima varianza)



# Prueba unitaria de la función de varianza
variance_1 = np.matmul(
    np.transpose(min_var_vector),                          # Transpone el vector de pesos
    np.matmul(mtx_var_covar, min_var_vector)               # Multiplica mtx * vector para obtener la varianza
)



# ======================================
# Mínima varianza con scipy.optimize.minimize
# ======================================

# Función objetivo: varianza del portafolio
def portfolio_variance(x, mtx_var_covar):
    variance = np.matmul(np.transpose(x), np.matmul(mtx_var_covar, x))  # Fórmula de varianza de portafolio
    return variance

# Vector inicial para el optimizador (distribución uniforme normalizada)
x0 = [1 / np.sqrt(len(tickers))] * len(tickers)  # Cada peso inicial es 1/√n



# Restricciones de norma L2 y L1 (elige una)
l2_norm = [{"type": "eq", "fun": lambda x: sum(x ** 2) - 1}]  # Los pesos deben tener norma L2 = 1
l1_norm = [{"type": "eq", "fun": lambda x: sum(abs(x)) - 1}]  # Los pesos deben sumar en valor absoluto = 1



# Optimización
optimal_result = op.minimize(
    fun=portfolio_variance,        # Función a minimizar
    x0=x0,                         # Punto inicial
    args=(mtx_var_covar,),         # Argumentos adicionales
    constraints=l2_norm            # Restricción elegida (aquí L2)
)

optimize_vector = optimal_result.x  # Extrae el vector de pesos óptimos
variance_2 = optimal_result.fun     # Varianza mínima resultante



# ======================================
# Construcción del DataFrame de resultados
# ======================================

df_weights = pd.DataFrame()                   # Crea un DataFrame vacío
df_weights['rics'] = tickers                 # Agrega columna con tickers
df_weights['min_var_vector'] = min_var_vector  # Pesos obtenidos por autovalores
df_weights['optimize_vector'] = optimize_vector # Pesos obtenidos por optimización

print(df_weights)                             # Muestra el DataFrame final

sum(min_var_vector ** 2)

((df_weights['optimize_vector']**2).sum())

(df_weights['min_var_vector']**2).sum()

"""¿Portafolios de Minima varianza?"""

# =====================================================================
# Lista de activos a incluir en el portafolio
# =====================================================================
tickers = [
    'XLK','XLF','XLV','XLP','XLY','XLE','XLI','XLC','XLB','XLU','XLRE'
]

# =====================================================================
# Cargar retornos diarios de cada activo y unirlos en un solo DataFrame
# =====================================================================
all_returns = []   # Lista donde se guardará un DataFrame por activo

for ticker in tickers:
    t = sfl.daily_return(ticker, data_dir="MarketData")      # Cargar retornos
    t = t[['date', 'return']].rename(columns={'return': ticker})  # Renombramos la columna return por el ticker
    all_returns.append(t)   # Lo guardamos en la lista

# Unimos todos los activos por la columna "date"
df = all_returns[0]
for t in all_returns[1:]:
    df = pd.merge(df, t, on='date', how='inner')   # Solo fechas compartidas

# Limpiamos y ordenamos
df = df.dropna().sort_values('date').reset_index(drop=True)

# Filtramos datos anteriores a 2019 (ventana histórica)
df = df[df['date']<'2019-01-01']

# =====================================================================
# Construcción de matriz de retornos y parámetros de Markowitz
# =====================================================================
mtx = df.drop(columns='date')    # Matriz solo de retornos
returns = mtx

# Retorno promedio anual de cada activo
mean_returns = returns.mean() * 252   # Multiplicado por días de mercado

# Matriz de covarianza anualizada
cov_matrix = returns.cov() * 252

n = len(tickers)   # Número de activos

# =====================================================================
# Función rendimiento y riesgo del portafolio
# =====================================================================
def portfolio_performance(weights):
    """
    Calcula retorno y volatilidad del portafolio.
    Fórmulas:
        rp = w^T μ
        σp = sqrt(w^T Σ w)
    """
    ret = np.dot(weights, mean_returns)                # w^T μ
    vol = np.sqrt(weights @ cov_matrix @ weights.T)    # sqrt(w^T Σ w)
    return ret, vol

# =====================================================================
# OPTIMIZACIÓN 1: Portafolio de mínima volatilidad
# =====================================================================
def minimize_volatility():
    x0 = np.ones(n)/n      # Condición inicial: pesos iguales
    bounds = tuple((0,1) for _ in range(n))  # Pesos entre 0 y 1 (no short)
    constraints = ({'type':'eq','fun':lambda w: np.sum(w)-1})  # Suma de pesos = 1

    # Minimizamos solo la volatilidad:
    # minimize( σp(w) )
    result = op.minimize(
        lambda w: portfolio_performance(w)[1],
        x0, constraints=constraints, bounds=bounds
    )
    return result.x, portfolio_performance(result.x)

# =====================================================================
# OPTIMIZACIÓN 2: Portafolio de máximo retorno
# =====================================================================
def maximize_return():
    x0 = np.ones(n)/n
    bounds = tuple((0,1) for _ in range(n))
    constraints = ({'type':'eq','fun':lambda w: np.sum(w)-1})

    # maximize(rp)  equivale a minimize(-rp)
    result = op.minimize(
        lambda w: -portfolio_performance(w)[0],
        x0, constraints=constraints, bounds=bounds
    )
    return result.x, portfolio_performance(result.x)

# =====================================================================
# OPTIMIZACIÓN 3: Portafolio de máximo Sharpe ratio
# =====================================================================
def maximize_sharpe(risk_free=0.0):
    """
    Sharpe ratio:
        S = (rp - rf) / σp
    maximize(S)  <--> minimize( -S )
    """
    x0 = np.ones(n)/n
    bounds = tuple((0,1) for _ in range(n))
    constraints = ({'type':'eq','fun':lambda w: np.sum(w)-1})

    def neg_sharpe(w):
        r, vol = portfolio_performance(w)
        return -(r - risk_free) / vol    # Negativo porque minimize() debe maximizar el Sharpe

    result = op.minimize(
        neg_sharpe, x0, constraints=constraints, bounds=bounds
    )
    return result.x, portfolio_performance(result.x)
# =====================================================================
# MODELO CLASICO
# =====================================================================

def min_variance_given_return(target_return):

    # Punto inicial: pesos iguales
    x0 = np.ones(n) / n

    # Restricciones: suma de pesos = 1  y retorno objetivo
    constraints = (
        {'type': 'eq', 'fun': lambda w: np.sum(w) - 1},                     # suma = 1
        {'type': 'eq', 'fun': lambda w: np.dot(w, mean_returns) - target_return}  # retorno deseado
    )

    # No permitir posiciones cortas (0 a 1)
    bounds = tuple((0, 1) for _ in range(n))

    # Función objetivo: varianza
    def variance(w):
        return w @ cov_matrix @ w.T

    # Optimización
    result = op.minimize(
        variance,
        x0,
        method='SLSQP',
        bounds=bounds,
        constraints=constraints
    )

    # Retornar pesos + rendimiento y riesgo resultante
    w = result.x
    ret, vol = portfolio_performance(w)

    return w, ret, vol


# =====================================================================
# EJECUCIÓN DE LOS MODELOS
# =====================================================================

# Portafolio de mínima varianza
w_min, (ret_min, vol_min) = minimize_volatility()

# Portafolio de máximo retorno
w_ret, (ret_mx, vol_mx) = maximize_return()

# Portafolio de máximo Sharpe
w_sharpe, (ret_s, vol_s) = maximize_sharpe()

target = 0.30   # 12% retorno objetivo
w_opt, r_opt, vol_opt = min_variance_given_return(target)


# =====================================================================
# RESULTADOS
# =====================================================================

def print_portfolio(name, weights, ret, vol):
    print(f"\n=== {name} ===")
    print("Ticker  |   Peso asignado")
    print("--------------------------")
    for t, w in zip(tickers, weights):
        print(f"{t:<6} | {w:.4f}")   # formatea pesos a 4 decimales
    print("Retorno esperado anual:", ret)
    print("Volatilidad anual:", vol)


# Imprimir resultados con tickers
print_portfolio("Portafolio Mínima Varianza", w_min, ret_min, vol_min)
print_portfolio("Portafolio Máximo Retorno", w_ret, ret_mx, vol_mx)
print_portfolio("Portafolio Máximo Sharpe", w_sharpe, ret_s, vol_s)
print_portfolio("Portafolio Máximo Sharpe_12%", w_opt, r_opt, vol_opt)

import numpy as np
import pandas as pd
import scipy.optimize as op
import matplotlib.pyplot as plt
import sf_library as sfl

# ==============================
# 1. Cargar retornos
# ==============================
tickers = [
    'XLK','XLF','XLV','XLP','XLY','XLE','XLI','XLC','XLB','XLU','XLRE'
]

all_returns = []
for ticker in tickers:
    t = sfl.daily_return(ticker, data_dir="MarketData")
    t = t[['date', 'return']].rename(columns={'return': ticker})
    all_returns.append(t)

df = all_returns[0]
for t in all_returns[1:]:
    df = pd.merge(df, t, on='date', how='inner')

df = df.dropna().sort_values('date').reset_index(drop=True)
df = df[df['date']<'2019-01-01']

returns = df.drop(columns='date')
mean_returns = returns.mean() * 252
cov_matrix = returns.cov() * 252
n = len(tickers)

# ==============================
# 2. Funciones base
# ==============================
def performance(weights):
    """ Retorno y volatilidad del portafolio """
    ret = np.dot(weights, mean_returns)
    vol = np.sqrt(weights @ cov_matrix @ weights.T)
    return ret, vol

def constraint_sum_weights():
    return {'type':'eq', 'fun':lambda w: np.sum(w) - 1}

bounds = tuple((0,1) for _ in range(n))   # NO short selling
x0 = np.ones(n) / n                        # Pesos iniciales iguales

# ==============================
# 3. Portafolio mínima varianza
# ==============================
def minimize_volatility():
    result = op.minimize(
        lambda w: performance(w)[1],
        x0,
        method='SLSQP',
        constraints=constraint_sum_weights(),
        bounds=bounds
    )
    return result.x, performance(result.x)

# ==============================
# 4. Portafolio máximo retorno
# ==============================
def maximize_return():
    result = op.minimize(
        lambda w: -performance(w)[0],
        x0,
        method='SLSQP',
        constraints=constraint_sum_weights(),
        bounds=bounds
    )
    return result.x, performance(result.x)

# ==============================
# 5. Portafolio máximo Sharpe
# ==============================
def maximize_sharpe(rf=0.0):
    def neg_sharpe(w):
        ret, vol = performance(w)
        return -(ret - rf) / vol

    result = op.minimize(
        neg_sharpe,
        x0,
        method='SLSQP',
        constraints=constraint_sum_weights(),
        bounds=bounds
    )
    return result.x, performance(result.x)

# ==============================
# 6. Frontera eficiente
# ==============================
def efficient_frontier(n_points=50):
    target_returns = np.linspace(mean_returns.min(), mean_returns.max(), n_points)
    frontier_vols = []
    frontier_rets = []

    for tr in target_returns:
        constraints = [
            constraint_sum_weights(),
            {'type': 'eq', 'fun': lambda w, tr=tr: np.dot(w, mean_returns) - tr}
        ]
        result = op.minimize(
            lambda w: performance(w)[1],
            x0,
            method='SLSQP',
            constraints=constraints,
            bounds=bounds
        )
        if result.success:
            vol = performance(result.x)[1]
            frontier_vols.append(vol)
            frontier_rets.append(tr)

    return np.array(frontier_vols), np.array(frontier_rets)

# ==============================
# 7. Ejecutar optimizaciones
# ==============================
w_min, (ret_min, vol_min) = minimize_volatility()
w_ret, (ret_mx, vol_mx) = maximize_return()
w_sharpe, (ret_s, vol_s) = maximize_sharpe()

# ==============================
# 8. Frontera eficiente
# ==============================
front_vols, front_rets = efficient_frontier()

# ==============================
# 9. Gráfico profesional
# ==============================
plt.figure(figsize=(10,6))

# Frontera eficiente
plt.plot(front_vols, front_rets, color='blue', linewidth=2, label="Frontera eficiente")

# Portafolio mínimo riesgo
plt.scatter(vol_min, ret_min, color='red', s=80, label="Min Var")

# Portafolio máximo Sharpe
plt.scatter(vol_s, ret_s, color='green', s=80, label="Máximo Sharpe")

# Portafolio máximo retorno
plt.scatter(vol_mx, ret_mx, color='purple', s=80, label="Máximo retorno")

plt.title("Frontera Eficiente - Modelo de Markowitz")
plt.xlabel("Volatilidad")
plt.ylabel("Retorno esperado")
plt.legend()
plt.grid(True)
plt.show()